
Scala - Programming Language 

Akka - Reactive Programming

Play   -Web Framework

Lagom - Microservice Framework
..............................................................................................
					 Scala
.............................................................................................

What is Scala?

 Scala is one of the Programming language for JVM.

Scala is Java?
  Yes.

What is Java ?
  Technology.

Technology means which solves Practical Problem.

What is the Problem java was trying to solve?

Application Portablity : If any app is built on native platform , cant be reused on different platform.

SUN Created JAVA Technology.

How java achived Portablity?
  Runtime - JRE - JVM

JVM is simple c program. JVM is virtual OS .
.............................................................................................
				in order to write apps on jvm

The programming language was needed -  java programming language.

What JPL?

 Java was created from idea of C++,SmallTalk.....

Java was created based on Object Oriented Programming style.
..............................................................................................
				 JCP -Java Community Process
..............................................................................................

The Java Community Process, established in 1998, is a formalized mechanism that allows interested parties to develop standard technical specifications for Java technology

JAVA editions:

1.JSE - Core java Language
2.JEE - For server side computing - Servlet,JSP,WebServices..... 
3.JME - For device computing


JSR - Java Specification Request

JVM languages:
.............

JSR 241  introduced new spec for jvm languages.

According to this spec, any body can create new pl for jvm.

Multi language spec. Other than java programming language, we can create new language.

Groovy - is first reference implementation based on JSR 241.
Scala
Kotlin
Clojure
.............................................................................................
				 
Java is Object oriented Programming language. - Before java 8

Java is Object oriented , functional Style Programming language.


Style of programming languages:

Today so many styles

1.object oriented programming.
2.Producural style
3.Functional programming
4.Event driven programming
5.Reactive Programming
etc...

..............................................................................................

Object Oriented Programming Principles:
.......................................


1.Abstraction
  You take necessary things from the object.
  class - is tool to capture object characteristics(state,behaviour,identity)
2.Encapsulation
  Hide and unhide  
  To limit code sharing across the application.
3.Hierarchy
   organization
  -has-a - compostion
  -IS-A - inheritance
4.Typing
  Type System
    - Strong Typing / Static Typing
    - Weak Typing/Dynamic Typing
   Polymorphism
     static poly
     dynamic poly
5.Modularity
   How to organize code
   packages
----------------------
6.Concurrency
   Threading
7.Persistency
   saving main memory data into disk and sending via network.
   seriazliation

If any language implements the first 5 principles, those languages are called object oriented
languages.
.............................................................................................
			Scala  =  OOP + Functional Programming
.............................................................................................

What is functional Programming?

The functional programming is the application of mathmetics-Lamda Calculs

Scala Language fundamentals
Scala Object Oriented Programming
Scala Functional Programming and implementations
............................................................................................
				Scala  - Scalable language

Scalable means expanding features.

Features:
1.new Data types -  we can create our own data types.
2.You can create readable new control constructs

Why scala?

1.scala comptible
2.scala is more concise

Employee.java
class Employee {
   private int id;
   private String name;
   public Employee(int id,String name){ 
    this.id = id;
    this.name =name;
  }
  //setters and getters

}

Employee.scala
class Employee(id:Int,name:String)

Scala is static typed language

 int a; - static type in java

 var | val a = 10

Type inference : Type of variable is fixed based on values assigned to a variable
   var a =10 
   val b =20;

Explicit type

 var | val a:Int =20

.............................................................................................
					Scala Setup
..............................................................................................

Many programming languages who provide REPL -  Read Evulate Print Loop

scala
Welcome to Scala 2.13.7 (Java HotSpot(TM) 64-Bit Server VM, Java 11.0.11).
Type in expressions for evaluation. Or try :help.

scala> "hello"
val res0: String = hello

scala> 10
val res1: Int = 10

scala> 20
val res2: Int = 20

scala> 30 + 90
val res3: Int = 120

scala> res3
val res4: Int = 120

scala> res4 *100
val res5: Int = 12000

scala> val msg="Hello Scala"
val msg: String = Hello Scala

scala> val message:String ="hello"
val message: String = hello

scala> val message:String ="hello"
val message: String = hello

scala> val name:java.lang.String="subramanian"
val name: String = subramanian

scala> println(name)
subramanian

scala> println("name "+name)
name subramanian

scala> println("Your name is $name" )
Your name is $name

scala> println("Your name is ${name}" )
Your name is ${name}

scala> name = "Ram"
            ^
       error: reassignment to val

scala> var age =18
var age: Int = 18

scala> println(age)
18

scala> age=100
// mutated age

scala> age=80
// mutated age

scala> println(age)
80

scala>
.............................................................................................

Scala tools:

1.scala compiler
 scalac 
2.scala runtime
  scala 

Scala scripting.

FileName.scala

Editors: 
 any text editor
 Ecplise
 Intellij idea.

Build tool for scala

sbt-Simple Build Tool
............................................................................................

How to create scala projects?

you can use sbt in commandline.

 sbt


you can use intellij idea

Code style: normal

HelloWorld.scala

object HelloWorld {
  //main method
  def main(args: Array[String]): Unit = {
    println("Hello")
  }
}

Code Style : dsl style
@main def hello: Unit = 
  println("Hello world!")
  println(msg)

def msg = "I was compiled by Scala 3. :)"
..............................................................................................
					Scala - Language Fundamentals
.............................................................................................

Variables
Types
Literals


Variables in Scala;

variables are declared in two styles

val -  immutable - constants, variables cant be reinitalized
 
var -  mutable  -  variables can reinitalized

package com.mycom

object VariablesDeclaration {
  def main(args: Array[String]): Unit = {
    val a = 10;
    println("A is " + a)
    //a = 100;
    var b = 100
    println("B is " + b)
    b = 900;
    println("B is " + b)

  }
}
..............................................................................................

Type System: Since scala is strongly typed , type of variable should be given.


int a =10; static typed syntax : java

Explicit type declaration
var a:Int  =10;

Type inference: Type of variable is fixed based on values
var a =100;

Types are objects in scala(Wrapper objects)

package com.mycom

object VariablesDeclaration {
  def main(args: Array[String]): Unit = {
    val a = 10;
    println("A is " + a)
    //a = 100;
    var b = 100
    println("B is " + b)
    b = 900;
    println("B is " + b)

    //Explicit type
    var c: Int = 90;
    println("C " + c);

  }
}

Built in data types:

Byte,Int,Long,Short,Double,Float,String

var i =10; ==> default is Int.

var j=10.4 ===>default is double

//java like suffix

var x=10L  => long

var y=10.5F => float

Large Numbers

var a = BigInt(222223232323)

var str="Hello" =>String
var c='c' =>Char

.............................................................................................

String has some special feature:

1.Interpolation : for string concatation 

package com.mycom

object StringsInScala {
  def main(args: Array[String]): Unit = {
    //strings:
    var firstName = "Subramanian";
    var lastName = "Murugan";
    println(s"Name : $firstName $lastName")
  }
}

here s is function for interpolating


2.Multi Line Strings

  //multi line strings
    var htmlDoc =
      """
        |<html>
        |<body>
        |<h1>Hello</h1>
        |</body>
        |</html>
        |""".stripMargin
    println (htmlDoc)
...........................................................................................
Control Structures:
..................

if..else
for loop and expressions
match expression - switch...case
while loop
try...catch

     var a =100;
     if a <0 then
      println("negative")
    else if a==0 then
       println ("zero")
     else
        println ("postive")


Scala code is full of expressions nor statement.

Expressions will give/return some value 
Statement will not return value.

expression

var res = 10 + 10(expression)

var res  = someFunc();

var res = new SomeClass();


package com.mycom

object ControlStructures {
  def main(args: Array[String]): Unit = {
    //control structure // Statement driven
    var a = 100;
    var b = 300;
    if (a < b) {
      println("good value")
    } else {
      println("bad value")
    }
    //control structure // expression driven
    val res = if (a > b) "A is greater" else "B is greater";
    println(res);

  }
}
..............................................................................................
Loops,switch..case
..................

For loops
 traditional for loop
 foreach method
 for expressions -based on eop 

package com.mycom

object Loops {
  def main(args: Array[String]): Unit = {
    //Collection
    //Seq
    val nums = Seq(1, 2, 3)
    for (n <- nums) println(n)
    //List
    val skills = List("Scala", "Java", "Microservices");
    //for loop
    for (skill <- skills) println(skill)
    //for each method
    skills.foreach(skill => println(skill))
    skills.foreach(println)
    //Maps
    val reviews = Map(
      "The Spider Man : No way Home" -> 4,
      "The Matrix Final Chapter " -> 3.5
    )
    for ((movie, rating) <- reviews) println(s"Movie => $movie Rating=> $rating")

  }
}
...........................................................................................
				Switch...case -Java , Match Expressions-Scala
..........................................................................................

Simple Match:

Statement based match

 val month = 3;
    //match expression
    month match {
      case 1 => println("Jan")
      case 2 => println("Feb")
      case 3 => println("Mar")
      case 4 => println("Apr")
      case _ => println("Invalid Month")
    }

Expression based match
 val monthName = month match {
      case 1 => "Jan"
      case 2 => "Feb"
      case 3 => "Mar"
      case 4 => "Apr"
      case _ => "Invalid Month"
    }
    println(monthName)
.........................................................................................

Range matching /List of values Matching

   val num = 6
    val evenOrOdd = num match {
      case 1 | 3 | 5 | 7 | 9 => "odd"
      case 2 | 4 | 6 | 8 | 10 => "even"
      case _ => "No match Found"
    }
    println(evenOrOdd)

    println(evenOrOdd)
    //Range Operator : DSL Code
    num match {
      case a if 0 to 9 contains(a) => println("0 to 9=>" + a)
    }

Advanced match expression to be discussed later.
.............................................................................................
				Object oriented Programming
............................................................................................

if you want to create object, we need class.

class types
1.normal class -  we can create instances
2.object class - SingleTon, which is holding static methods

package com.mycom.oop

class Greeting {
  //instance variables
  var name = "Subramanian";
  var message = "Hello";
}

This is normal class
package com.mycom.oop

/**
 * public class GreetingMain {
 * public static void main(String args[]){
 *
 * }
 * }
 * GreetingMain.main()
 */
//Single ton means , can have static methods , in scala there is no static keyword
object GreetingMain {
  def main(args: Array[String]): Unit = {
    var greeting = new Greeting();
    println(s"${greeting.name} ${greeting.message}")
    greeting = new Greeting(); //constructor call
    greeting.message = "Hai";
    greeting.name = "Ram";
    println(s"${greeting.name} ${greeting.message}")
    //No need of() incase of default constructors
    greeting = new Greeting //constructor call
    println(s"${greeting.name} ${greeting.message}")
  }
}
.............................................................................................

Methods:
 methods are part of classes(instance)

package com.mycom.oop

class Calculator {
  //add methods
  def addV1(): Int = {
    println("Add method")
    return 10 + 10;
  }

  //methods with args
  def addV2(a: Int, b: Int): Int = {
    return a + b;
  }

  //default args
  def addV3(a: Int = 0, b: Int = 0): Int = {
    return a + b;
  }

  //if method having single ling of body ; we can remove {} and return statement
  def addV4(a: Int = 2333, b: Int = 99999): Int = a + b

  //multi line body without return statement
  def addV5(a: Int = 2333, b: Int = 99999): Int = {
    println("addV5")
    println("This is nice syntax")
    a + b // last line of code is implied as return value
  }


}

package com.mycom.oop

object ObjectMethods {
  def main(args: Array[String]): Unit = {
    val calculator = new Calculator;
    println(calculator.addV1())
    println(calculator.addV2(12,30))
    println(calculator.addV3())
    println(calculator.addV3(2,90))
    println(calculator.addV3(12))
    println(calculator.addV4())
    println(calculator.addV5())

  }
}
........
File names and class Names:

in Scala, you can name
.scala files anything you want, no matter what Scala classes or code you
put in them. In general in the case of non-scripts, however, it is recommended
style to name files after the classes they contain as is done in Java.

foo.scala

class Bar {} //valid

but recommended

Bar.scala
class Bar {}

..........................................................................................
constructors:
.............
Types of constructors
1.primary constructors
2.axilary constructors


1.primary constructors.

1.Constructor parameters are declared as part of class Declaration

  class Employee(var id:Int,var name:String) {



  }
2.class body becomes constructors body , so you can call methods directly.

  class Employee(var id:Int,var name:String) {
     println("you can call")
     doStuff()
  }
..........................................

package com.mycom.oop

class Employee(var id: Int = 0, var firstName: String = "", var lastName: String = "") {
  override def toString: String = s"${id} $firstName $lastName"
}

//if class has no methods only data : data class //no necessary of {}
class Stock(var symbol: String = "google", var price: BigDecimal = 100)

//if class has a  releation ship
class Address(
               var street: String = "street",
               var city: String = "city",
               var state: String = "state"
             )

class Customer(var id: Int = 0, var name: String = "name", var address: Address = new Address)

//class constructors are used to have expression

class Guest(var firstName: String = "firstName") {
  //body of the constructor
  println("Guest is being initialized")
  //variables
  var from: String = "From city"

  //methods
  def printCity(): Unit = println(this.firstName, this.from)

  printCity()
}

///Auxiliary class constructors

/**
 * 1.it is special method started with this keyword
 * 2.those constructors must be called by other constructors
 */
class Building(var totalSize: Int = 0, var buildingType: String = "") {
  //one arg aux constructor
  def this(totalSize: Int) = {
    this(totalSize, "Home")
    println("Single Arg constructor is called")
  }

}

package com.mycom.oop

object ConstructorsMain {
  def main(args: Array[String]): Unit = {
    var employee = new Employee; //default constructor
    println(employee.toString)
    employee = new Employee(1, "subramanian", "Murugan"); //default constructor
    println(employee.toString)

    employee = new Employee(3); //default constructor
    println(employee.toString)
    //named parameters : help to pass values in any order
    employee = new Employee(lastName = "Murugan")
    println(employee.toString)

    //instance of Stock
    val stock = new Stock()
    println(stock.price, stock.symbol)

    var customer = new Customer;
    println(customer.id, customer.name, customer.address.city)
    customer = new Customer(id = 1, name = "Subramanian", address = new Address(city = "Coimbatore"))
    println(customer.id, customer.name, customer.address.city)

    //constructor blocks
    var guest = new Guest
    var building = new Building
    building = new Building(1800)
  }
}
.............................................................................................
				  Traits  - Like interfaces in Java
..............................................................................................

Traits:

Traits are a fundamental unit of code reuse in Scala. A trait encapsulates
method and field definitions, which can then be reused by mixing them into
classes. Unlike class inheritance, in which each class must inherit from just
one superclass, a class can mix in any number of traits.

A trait definition looks just like a class definition except that it uses the keyword
trait.

Types:
1.class
2.Interface - traits = abstract classes  + interfaces
3.Enum
4.abstract class

Hierchary: 
 Has-a -Compostion.
 IS-A - inheritance

Inheritance:
=>Code Reuse
=>To avoid code duplication.

Across the application or Across the hierachy.


package com.mycom.oo.traits

//trait
trait Flyable {
  //abstract methods and non abstract methods
  def fly(): String;
}

class AirPlane extends Flyable {
  override def fly(): String = "Airplan is flying"
}

object TraitsDemo {
  def main(args: Array[String]): Unit = {
    // var airPlane:Flyable = new AirPlane;
    var airPlane = new AirPlane;
    println(airPlane.fly);
  }
}
...............................
Mutliple Traits:
package com.mycom.oo.traits

//trait
trait Flyable {
  //abstract methods and non abstract methods
  def fly(): String;
}

trait Landable {
  def land(): String;
}

trait TakeOff {
  def takeOff(): String;
}

class AirPlane extends Flyable with Landable with TakeOff {
  override def fly(): String = "Airplan is flying"

  override def land(): String = "Landing Process begins";

  override def takeOff(): String = "Take Off Process begins"
}

object TraitsDemo {
  def main(args: Array[String]): Unit = {
    // var airPlane:Flyable = new AirPlane;
    var airPlane = new AirPlane;
    println(airPlane.fly, airPlane.land, airPlane.takeOff);
  }
}
............................................................................................

Trait and concrete Methods:
trait Pet {
  def speak = println("wo wo wo") // concrete implementation of a speak method

  def eat(): String // abstract
}

class Dog extends Pet {
  override def eat(): String = "Dog eats meat and bones"
}

def main(args: Array[String]): Unit = {
    // var airPlane:Flyable = new AirPlane;
    var airPlane = new AirPlane;
    println(airPlane.fly, airPlane.land, airPlane.takeOff);
    ///
    var pet = new Dog;
    pet.speak
    println(pet.eat)

}
............................................................................................
	   Anonomous Classes: without Implementation class we can write logic
		Runtime Inheritance: BindingMixing traits in on the fly

Use case 1:without any class


    var myCat = new Pet {
      override def eat(): String = "Cat is drinking Milk"
    }
    myCat.speak
    println(myCat.eat)

Use case 2: with class but binding happens dynamically.


trait Pet {
  def speak = println("wo wo wo") // concrete implementation of a speak method

  def eat(): String // abstract
}

def cat = new Cat("puppy") with Pet {
      override def eat(): String = "Cat Drinks milk"
    }
    cat.speak
    println(cat.eat)

......
// this won’t compile
trait Animal(name: String)


Abstract classes:
 Like java classes.

Therefore, you need to use an abstract class whenever a base behavior must have constructor parameters:

abstract class Pet(name: String) {
  def speak: Unit = println(s"My name is $name")
  //non abstracts
  def takeCare(): Unit = {
    println("Take Care Pets")
  }
}

class Dog(name: String) extends Pet(name)

object AbstractClassesDemo {
  def main(args: Array[String]): Unit = {
    var dog = new Dog("Fido")
    dog.speak
    dog.takeCare
  }
}

}
..........................................................................................

package com.mycom.oop.advancedmatch

trait Person {
  def name: String
}

case class Student(name: String, year: Int) extends Person

case class Teacher(name: String, specialty: String) extends Person

class CasePrinter {
  def getPrintableString(p: Person): String = p match {
    case Student(name, year) =>
      s"$name is a student in Year $year."
    case Teacher(name, whatTheyTeach) =>
      s"$name teaches $whatTheyTeach."
  }
}

object AdvancedMatchClass {
  def main(args: Array[String]): Unit = {
    val casePrinter = new CasePrinter
    println(casePrinter.getPrintableString(new Student("Ram", 3)))
    println(casePrinter.getPrintableString(new Teacher("Subramanian", "Scala")))

  }
}
package com.mycom.oop.advancedmatch

trait Person {
  def name: String
}

case class Student(name: String, year: Int) extends Person

case class Teacher(name: String, specialty: String) extends Person

class CasePrinter {
  def getPrintableString(p: Person): String = p match {
    case Student(name, year) =>
      s"$name is a student in Year $year."
    case Teacher(name, whatTheyTeach) =>
      s"$name teaches $whatTheyTeach."
  }
}

//case class Methods
case class IPLTeam(name: String, lastWorldSeriesWin: Int)

object AdvancedMatchClass {
  def main(args: Array[String]): Unit = {
    val casePrinter = new CasePrinter
    println(casePrinter.getPrintableString(new Student("Ram", 3)))
    println(casePrinter.getPrintableString(new Teacher("Subramanian", "Scala")))

    val cubs1908 = IPLTeam("CSK", 2021)
    println(cubs1908.name, cubs1908.lastWorldSeriesWin)

    val cubs2016 = cubs1908.copy(lastWorldSeriesWin = 2017)
    
    println(cubs2016.name, cubs2016.lastWorldSeriesWin)

  }
}
..............................................................................................

Built in Usefull Traits:

Null, null, Nil, Nothing, None, and Unit in Scala
....................................................

Null– Its a Trait.
null– Its an instance of Null- Similar to Java null.

Nil– Represents an emptry List of anything of zero length. Its not that it refers to nothing but it refers to List which has no contents.

Nothing is a Trait. Its a subtype of everything. But not superclass of anything. There are no instances of Nothing.

None– Used to represent a sensible return value. Just to avoid null pointer exception. Option has exactly 2 subclasses- Some and None. None signifies no result from the method.

Unit– Type of method that doesn’t return a value of anys sort.
...............................................................................................				Functional Programming
..............................................................................................
				
What is functional Programming?
 
 The Programming style or paradigm.

 The functional programming is based on Mathmetical abstractions.

 The functional programming is implementation of Lambda calculus


What is Lambda calculus?
  Lambda calculus (also written as λ-calculus) is a formal system in mathematical logic for "expressing computation based on function abstraction and application using variable binding and substitution". It is a universal model of computation that can be used to simulate any Turing machine.

computation based on function abstraction :

What is function ? 
   Unit of computation

Lambda calculus is mathmetical Algebraic expression, developed to solve  to simulate Turing machine.

Turing Machine is abstract computer(machine).

.............................................................................................

History of Lambda Calculus(Why Lambda Calculus) :

It was introduced by the mathematician Alonzo Church in the 1930s as part of his research into the foundations of mathematics.

Alonzo Church was PHD student under "Alan Turing"  who invented turing machine, which also abstract and real machine which stores values , mutates those values.

How turing machine works?

  Turing machines changes the state of memory address directly which leads data inconsistency 
and corruption.

Chruch identifed this problem, gave another solution called "Lambda calcuculs"

Lambda calculus provides two impartant properties;

1.immutablity
    Dont change the original memory address of state.
    Dont mutate the state on direct memory address.
2.Pure functions
    The function which is responsible for computation.


The programming languages which implements 'lambda calculus' those languages are called "Functional Programming".

The first fp language based lambda calculus was "LISP"


Functional Programming principles:
..................................

1.pure functions 
   =>impure function,side effects/disciplined states
2.Immutablity
   =>state mutatations
3.Functions are first class citizens 

4.Higher order Functions

5.Referetial transparency

6.Recurrsion over loops


Functional Style vs Pure functionals:

 if any programming lanuage follows all the principles 100%, those languages are called "Pure funcitonal programming language" eg : Haskell

if any programming lanugage does not follow all principles, those languages are called "
functional style lanugage" - javascript,scala,Kotlin,java8,python....

............................................................................................
                                 Scala Functional Programming principles

1.pure functions and immutablity
2.Function is first class citizen - function literals  - anonmous functions / lambda - code as data- expressions
3.Higher order functions


Functions are first class citizen:
..................................

First class Citizen: (special):

functions are passed around .(in,out)

This means the language supports passing functions as arguments to other functions, returning them as the values from other functions, and assigning them to variables or storing them in data structures

functions are literals , means values like int,double,string

val a =10;(literal)

val myjob = fun doStuff(){}
 
Scala functions are first class -  which means that they can be stored in variables and ds,passed as arg to and return from other functions.


Higer order function:

First-class functions are a necessity for the functional programming style, in which the use of higher-order functions is a standard practice. 


In mathematics and computer science, a higher-order function is a function that does at least one of the following:

->takes one or more functions as arguments,
->returns a function as its result.


Can i say this fun is Higher order fun?

fun  map(){

}
Ans: No because it does not follow the thumb rule of higher order function.

Since Scala static typed language, we need to tell type of "function" itself

fun  map(FunctionType){

}
.............................................................................................

Function Literal/ Lambda expression:
......................................

Expression:

int a  =10;
int b =20;
int c  = a*b; /expression

Lambda :

It is special expression, where the variable is going to hold "function reference".
Lambda expression.


var | val functionName = function Defintion

    var sayHai = () => {
      println("Lambda expression !")
    }
    println(sayHai.getClass())

Note: every lambda behind the scene is "Object" only.

package com.mycom.fp

object FunctionLiterals {
  def main(args: Array[String]): Unit = {

    var sayHai = () => {
      println("Lambda expression !")
    }
    println(sayHai.getClass())
    sayHai();

    //lambda syntax simplification : if lambda has no body you can omit {}
    sayHai = () => println("Lambda expression !")
    sayHai();

    //if multi line you can keep {} but not necessary
    sayHai = () => {
      println("Hello")
      println("Hai!!!!")
    }
    sayHai();

    //Lambda with parameters : Lambda must not have explicit return statement.
    var add = (a: Int, b: Int) => {
      a + b;
    }
    println(add(10, 10))
    //lambda without {}
    add = (a: Int, b: Int) => a + b
    println(add(10, 106))

    //returning expressions
    var greeter = () => "Welcome to Scala ";
    println(greeter())
    //no args only expression
    greeter = () => {
      "Welcome to Scala "
    }
    println(greeter())
    ////////////////////////////////////////////////////////////////////////////////////////////
    //Skipping parameter names
    var myfun = (firstName: String, lastName: String) => firstName + lastName;
    println(myfun("Subramanian","Murugan"))

    //_wild card chracter to remove declaration
    var myfc2 = (_:String) + (_:String)
    println(myfc2("Subramanian","Murugan"))
    var adder = (_:Int) + (_:Int)
    println(adder(10,10))

  }
}
..............................................................................................
				  Higher order Functions
..............................................................................................

Higher order function is a function which takes function as parameter and also returns function.

Function as parameter to another function:
..........................................

How function is as parameter?

 Since function is literal, so we can pass around(in and out).


Function as Parameter:

package com.mycom.fp

object HigherOrderFunctions {
  def main(args: Array[String]): Unit = {
    //declare lambda - function literal
    var hello = () => println("Hello");
    sayGreet(hello)
    //anonymous function - passing function directly without storing into an variable
    sayGreet(() => println("Hello Again"))
    //function with parameters
    var hai = (name: String) => println(s"Hai ${name}");
    sayHai(hai);
    sayHai((name: String) => println(s"Hai ${name}"));

    //function with return value
    var howareYou = (name: String) => s"How Are you?  ${name}";
    sayHowAreY(howareYou);
    sayHowAreY((name: String) => s"How Are you?  ${name}");

    //more parameters
    login("admin", "admin", (status: String) => println(status), (err: String) => println(err))
    login("adminxxx", "admin", (status: String) => println(status), (err: String) => println(err))

    //Type inference in higher order functions
    login("admin", "admin", status => println(status), err => println(err))

    //type inference works only for inline anonmous functions
    var howareYou1 = (name: String) => s"How Are you?  ${name}";
    sayHowAreY(howareYou1);
    sayHowAreY(name => s"How Are you?  ${name}");

  }

  /**
   * function sayStreet(action){
   * action();
   * }
   * let hello = function(){
   * console.log('Hello');
   * }
   * sayGreet(hello)
   *
   */

  //method
  //action = () => println("Hello");
  def sayGreet(action: () => Unit): Unit = {
    //invoke the function which was passed
    action()
  }

  //callback function ; here action:DataType
  def sayHai(action: (String) => Unit): Unit = {
    action("Subramanian")
  }

  def sayHowAreY(action: (String) => String): Unit = {
    var res = action("Subramanian");
    println(res);
  }

  //
  def login(userName: String, password: String, success: (String) => Unit, failure: (String) => Unit): Unit = {
    //biz logic
    if (userName.equals("admin") && password.equals("admin")) {
      success("Login Successful")
    } else {
      failure("Login failed")
    }
  }


}
..............................................................................................
		 How to return function from another function


val add = (a: Int, b: Int) => a + b
println(add(10, 106))

here were are returning integer value.


package com.mycom.fp

object ReturnFunctions {
  def main(args: Array[String]): Unit = {
    var res = sayGreet();
    //invoke the function.
    res();
    var hai = sayHai()
    hai();

    def names = getName();
    println (names("Subramanian", "Murugan"))

    //short cuts
    sayGreet()();
    println(getName()("Subramanian","Murugan"))

  }

  //here function returns string
  //  def sayGreet (): String = {
  //     "Hello"
  //  }
  //here function returns "function"
  def sayGreet(): () => Unit = {
    //return function
    var hai = () => println("Hello")
    hai
  }

  def sayHai(): () => Unit = {
    //returning function
    () => println("Hello")
  }

  //parameters for returning function
  def getName(): (String, String) => String = {
    (firstName: String, lastName: String) => s"${firstName} ${lastName}"
  }
}
..............................................................................................
				   Curry
..............................................................................................

What is Curry?
In mathematics and computer science, currying is the technique of converting a function that takes "multiple arguments" into a sequence of functions that each takes a single argument.

lets assume a function takes two arg

 def sum(x:Int,y:Int):Int = x + y

 sum(10,10)

Why Curry Functions? What is application of curry function?

eg:ATM
 ATM works by calling sequence of functions.

 InsertCard
 ReadCard
 AcceptPIn
 TransactionType
 WithDraw
 etc...


package com.mycom.fp

object CurryFunctions {
  def main(args: Array[String]): Unit = {
    val sumRes = sum(10, 10)
    println(s" Sum => $sumRes")
    //calling curry version of method
    println(sumCurry(12)(12))

    //lambda curry
    //regular lambad
    val sumV2: (Int, Int) => Int = (x, y) => x + y;
    //curry function
    var curriedSum: Int => Int => Int = sumV2.curried
    println(curriedSum(10)(10))
    var amount = atm("8883434")(1234)(10000.00)
    println(s"Amount  withdrawn => ${amount}")

  }

  //regular function
  def sum(x: Int, y: Int): Int = x + y

  //curry version of sum. // method syntax
  def sumCurry(x: Int)(y: Int): Int = x + y

  //atm simulation
  def atm(cardIn: String)(accpetPin: Int)(withdrawAmt: Double) = s"${cardIn} ${withdrawAmt}"

}
..............................................................................................
				Partial Applications / Functions
..............................................................................................

What is Partial Applications? Partial Functions

In computer science, partial application (or partial function application) refers to the process of "fixing a number of arguments to a function", "producing another function" of smaller arity.

f:(x,y,z)->N , here we can fix(bind) first parameter is constant, remain two parameters are dynamic.

fParital(y,z)
package com.mycom.fp

object PartialFunction {
  def main(args: Array[String]): Unit = {
    //create new function called "partial function"
    var seedValue = 10;
    //increment by 2 , suppling seedvalue
    val increment = sum(seedValue)(_)
    println(increment(2))
    println(increment(20))
    println(increment(29))
    // lambda version
    val sumV2: (Int, Int) => Int = (x, y) => x - y;
    var curriedSum: Int => Int => Int = sumV2.curried
    //partial 
    var decrement: Int => Int = curriedSum(12)(_);
    println(decrement(10))
  }

  def sum(x: Int)(y: Int): Int = x + y;
}
...............................................................................................				 Closure


A closure is a function, whose return value depends on the value of one or more variables declared outside this function.

The following piece of code with anonymous function.

val multiplier = (i:Int) => i * 10

Here the only variable used in the function body, i * 10 , is i, which is defined as a parameter to the function. Try the following code −


var factor = 3

val multiplier = (i:Int) => i * factor


There are two free variables in multiplier: i and factor. One of them, i, is a formal parameter to the function. Hence, it is bound to a new value each time multiplier is called. However, factor is not a formal parameter, then what is this? Let us add one more line of code.

var factor = 3
val multiplier = (i:Int) => i * factor
Now factor has a reference to a variable outside the function but in the enclosing scope. The function references factor and reads its current value each time. If a function has no external references, then it is trivially closed over itself. No external context is required.
.............................................................................................
package com.mycom.fp

object ClosureFunctions {
  def main(args: Array[String]): Unit = {
    var factor = 3
    val multiplier = (i: Int) => i * factor
    println(multiplier(10))
    println(multiplier(5))

  }
}
..............................................................................................
				Null Values in Functional Programming.


What is null?					
   null is value similar to strings,numbers,objects.
   null represents invalid object. you have not assigned valid values to reference variable.
  
Pain points of null:
  null causes runtime error, which crashes the system.
  
No Null values:
	Functional programming is like writing a series of algebraic equations, and because you don’t use null values in algebra, you don’t use null values in FP. That brings up an interesting question: In the situations where you might normally use a null value in Java/OOP code, what do you do?

Scala’s solution is to use constructs like the Option/Some/None classes.


Code with Exception
....................
package com.mycom.fp

object NoNullPointer {
  def main(args: Array[String]): Unit = {
    //with null pointer exception
    //println(convert("100"));
    //println(convert("100xx"));
    // convert("100xxx")
    convert(null)


  }

  def convert(number: String): Unit = {
    println(Integer.parseInt(number.trim()))
    //    try {
    //       //risky code : the code which may cause error at time.
    //        println(Integer.parseInt(number.trim()))
    //    } catch {
    //      case e: Exception => println (e)
    //    }
  }
}

How to return some value instead of exception?

Solution 1:
 inside case we can return some value

package com.mycom.fp

object NoNullPointerV2 {
  def main(args: Array[String]): Unit = {
    println(convert("100"));
    println(convert("100xx"));
  }

  def convert(number: String): Int = {
    try {
      //risky code : the code which may cause error at time.
      Integer.parseInt(number.trim())
    } catch {
      case e: Exception => 0
    }
  }
}
\
Here if a string converts to an integer, you return converted result in Int.
if conversion fails you return 0 which is also Int.
instead of 0 i want to return something else like "sorry this is wrong number"


How to solve this? Scala Provides Option/Some/None Types;
............................................................

Option is Super class of Some and None

				   Option
				     |
			    -----------------------	
			  Some                    None	

In oo(Java/C#), the parent type /super type can be return type and returned value type can be sub type of that

eg in java:

 public Object getValue(){
     return "Hello"
 }
 public Object getValue(){
     return 10
 }
 public Object getValue(){
     return new Employee()
 }


Using Some/Option/None:
.......................
package com.mycom.fp

object NoNullPointerV3 {
  def main(args: Array[String]): Unit = {
    println(convert("100"));
    println(convert("100xx"));
    //extract value from the Some
    println(convert("100").get);
    println(convert("100").getOrElse("0"));
    println(convert("100xx").getOrElse("sorry this is wrong number"));
    

  }

  def convert(number: String): Option[Int] = {
    try {
      //risky code : the code which may cause error at time.
      Some(Integer.parseInt(number.trim())) // Some[Integer]
    } catch {
      case e: Exception => None
    }
  }
}
..........................................................................................
		  Handling Some and Options using match expressions
..........................................................................................

package com.mycom.fp

object NoNullPointerV4 {
  def main(args: Array[String]): Unit = {
    //using case expressions
    var someNumber = "10xxx"
    convert(someNumber) match {
      case Some(i) => println(i)
      case None => println("sorry this is wrong number")
    }

  }

  def convert(number: String): Option[Int] = {
    try {
      //risky code : the code which may cause error at time.
      Some(Integer.parseInt(number.trim())) // Some[Integer]
    } catch {
      case e: Exception => None
    }
  }
}

Some is a container with one item in it. -> success items
None is a container , but it has nothing in it - failed items

..............................................................................................
		   Object and Null values: Using Option how to replace null


package com.mycom.fp

class Employee(
                var firstName: String,
                var lastName: String,
                var city: String,
                var salary: Double
              )


object NoNullPointerV5 {
  def main(args: Array[String]): Unit = {
    val emp = new Employee("Subramanian", "Murugan", null, 5000);
    println(s"${emp.firstName} ${emp.lastName} ${emp.city.toUpperCase()} ${emp.salary}")
  }
}

when you run this code
Exception in thread "main" java.lang.NullPointerException
	at com.mycom.fp.NoNullPointerV5$.main(NoNullPointerV5.scala:14)
	at com.mycom.fp.NoNullPointerV5.main(NoNullPointerV5.scala)


How to solve this problem, how to avoid NullPointerException.


package com.mycom.fp

//class Employee(
//                var firstName: String,
//                var lastName: String,
//                var city: String,
//                var salary: Double
//              )

class Employee(
                var firstName: Option[String],
                var lastName: Option[String],
                var city: Option[String],
                var salary: Option[Double]
              )

object NoNullPointerV5 {
  def main(args: Array[String]): Unit = {
    //    val emp = new Employee("Subramanian", "Murugan", null, 5000);
    //    println(s"${emp.firstName} ${emp.lastName} ${emp.city.toUpperCase()} ${emp.salary}")
    val emp = new Employee(Some("Subramanian"), Some("Murugan"), None, Some(5000));
  //    println(s"${emp.firstName} ${emp.lastName} ${emp.city} ${emp.salary}")
    println(s"${emp.firstName.get} ${emp.lastName.get} ${emp.city.getOrElse("default City")} ${emp.salary.get}")
  }
}
..............................................................................................
DSL:

Programming languages are classified into

1.GPL
  General Purpose Programming language.
  Java,C++,C#,C
  ->Language created for any type of apps using imperative programming model
2.DSL
  Domain Specific language
   Lanaguage only one domain.
  HTML.
    Declarative -  More readable looks like english statement
   eg:
     deposit 100 in account no 3944  -  program.

 How to create dsls - using functional and object oriented programming.

 DSLs are programms usefull for stack holders, dev ops eng,biz anay,testers.

Programming languages such as groovy.

package com.mycom.fp

object Response {
  def response() = "Message Processed"
}

object Behaviours {
  //method : higher order function
  def receive(onMessage: () => Unit) = {
    //calling function
    onMessage();
    //traditional method call
    //Response.response();
    //dsl like method call
    Response.response
  }
}


object LambdaAsArg {
  def main(args: Array[String]): Unit = {
    //lnline lambda expression
    Behaviours.receive({ () =>
      println("Hello")
    });
    //simple short cut : DSL Syntax
    var res = Behaviours.receive { () =>
      println("Hello DSL Syntax")
    }
    println(res);
  }
}
.............................................................................................

How to omit main method?
object LambdaAsArg extends App {
  Behaviours.receive({ () =>
    println("Hello")
  });
  //simple short cut : DSL Syntax
  var res = Behaviours.receive { () =>
    println("Hello DSL Syntax")
  }
  println(res);
}
.............................................................................................
				Pure and Impure functions and Immutablity
.............................................................................................

What is pure function?

=>The function's out put depends on only its input
  if function receives input, the function should return the same

eg 
    function myfun(var a){
        return a;
    }
Side Effects  && Impure functions
 
  if function tries to mutate(update/change) the function args or function local variable
  or object instance variable.
  if function tries to do some io operations -  like writing into logs,dbs,fs...
  
  if function does the same , it is said to be impure functions, and also side effects

=>What if the function gets input, needs to mutate its input parameter,but that function needs to be pure.
  Solution: Immutablity

impure version:
   function updateProfile(var profile,var city){
       
       //side effects
     profile.city = city;
     return profile
       
   }

pure with immutability
  function updateProfile(var profile,var city){
     //we have to return new object every time when ever we modify the state.
     return  profile.clone(city:city)
       
   }
eg in java 
 Strings 

  String str = "hello";
  String newStr = str.trim()

Scala provides lot of pure functions.

scala.Math package
 abs
 ceil
 max
 min
Scala stringss
 isEmpty
 length
 substring

Collections are also avaiable in pure function version. => Immutable Collections

..............................................................................................	
				 Data Structure in Scala - Collections
..............................................................................................

Static/Fixed
  Arrays
Dynamic
  List
  Set
  Map

Scala collections are immutable and mutable .


A Mutable collection can be updated or extended in place.Which causes side effects
Immutable collection  the original memory address never change- rather it creates new copy of object every time.

scala.collection.mutable 
scala.collection.immutable

package com.mycom.collections

object CollectionsDemo extends App {
  //Lists are ordered collection based on index
  //generics : generics are containers which provide type safety for container objects like list,set
  var list: List[Int] = List(1, 2, 3);
  list.foreach(f => {
    println(f)
  })
  //short cuts
  list.foreach(f => println(f))
  //method reference
  list.foreach(println)
  //set is unordered collections, which avoid duplicates
  var names: Set[String] = Set("a", "b", "c", "d", "a", "e");
  names.foreach(println);
  //Map is key-value paried
  var colorCodes: Map[String, String] = Map("red" -> "#F002323", "blue" -> "#B000")
  println(colorCodes.keys)
  println(colorCodes.values)

}
.............................................................................................


















































































































   

   

 