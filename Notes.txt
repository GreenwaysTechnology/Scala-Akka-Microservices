
Scala - Programming Language 

Akka - Reactive Programming

Play   -Web Framework

Lagom - Microservice Framework
..............................................................................................
					 Scala
.............................................................................................

What is Scala?

 Scala is one of the Programming language for JVM.

Scala is Java?
  Yes.

What is Java ?
  Technology.

Technology means which solves Practical Problem.

What is the Problem java was trying to solve?

Application Portablity : If any app is built on native platform , cant be reused on different platform.

SUN Created JAVA Technology.

How java achived Portablity?
  Runtime - JRE - JVM

JVM is simple c program. JVM is virtual OS .
.............................................................................................
				in order to write apps on jvm

The programming language was needed -  java programming language.

What JPL?

 Java was created from idea of C++,SmallTalk.....

Java was created based on Object Oriented Programming style.
..............................................................................................
				 JCP -Java Community Process
..............................................................................................

The Java Community Process, established in 1998, is a formalized mechanism that allows interested parties to develop standard technical specifications for Java technology

JAVA editions:

1.JSE - Core java Language
2.JEE - For server side computing - Servlet,JSP,WebServices..... 
3.JME - For device computing


JSR - Java Specification Request

JVM languages:
.............

JSR 241  introduced new spec for jvm languages.

According to this spec, any body can create new pl for jvm.

Multi language spec. Other than java programming language, we can create new language.

Groovy - is first reference implementation based on JSR 241.
Scala
Kotlin
Clojure
.............................................................................................
				 
Java is Object oriented Programming language. - Before java 8

Java is Object oriented , functional Style Programming language.


Style of programming languages:

Today so many styles

1.object oriented programming.
2.Producural style
3.Functional programming
4.Event driven programming
5.Reactive Programming
etc...

..............................................................................................

Object Oriented Programming Principles:
.......................................


1.Abstraction
  You take necessary things from the object.
  class - is tool to capture object characteristics(state,behaviour,identity)
2.Encapsulation
  Hide and unhide  
  To limit code sharing across the application.
3.Hierarchy
   organization
  -has-a - compostion
  -IS-A - inheritance
4.Typing
  Type System
    - Strong Typing / Static Typing
    - Weak Typing/Dynamic Typing
   Polymorphism
     static poly
     dynamic poly
5.Modularity
   How to organize code
   packages
----------------------
6.Concurrency
   Threading
7.Persistency
   saving main memory data into disk and sending via network.
   seriazliation

If any language implements the first 5 principles, those languages are called object oriented
languages.
.............................................................................................
			Scala  =  OOP + Functional Programming
.............................................................................................

What is functional Programming?

The functional programming is the application of mathmetics-Lamda Calculs

Scala Language fundamentals
Scala Object Oriented Programming
Scala Functional Programming and implementations
............................................................................................
				Scala  - Scalable language

Scalable means expanding features.

Features:
1.new Data types -  we can create our own data types.
2.You can create readable new control constructs

Why scala?

1.scala comptible
2.scala is more concise

Employee.java
class Employee {
   private int id;
   private String name;
   public Employee(int id,String name){ 
    this.id = id;
    this.name =name;
  }
  //setters and getters

}

Employee.scala
class Employee(id:Int,name:String)

Scala is static typed language

 int a; - static type in java

 var | val a = 10

Type inference : Type of variable is fixed based on values assigned to a variable
   var a =10 
   val b =20;

Explicit type

 var | val a:Int =20

.............................................................................................
					Scala Setup
..............................................................................................

Many programming languages who provide REPL -  Read Evulate Print Loop

scala
Welcome to Scala 2.13.7 (Java HotSpot(TM) 64-Bit Server VM, Java 11.0.11).
Type in expressions for evaluation. Or try :help.

scala> "hello"
val res0: String = hello

scala> 10
val res1: Int = 10

scala> 20
val res2: Int = 20

scala> 30 + 90
val res3: Int = 120

scala> res3
val res4: Int = 120

scala> res4 *100
val res5: Int = 12000

scala> val msg="Hello Scala"
val msg: String = Hello Scala

scala> val message:String ="hello"
val message: String = hello

scala> val message:String ="hello"
val message: String = hello

scala> val name:java.lang.String="subramanian"
val name: String = subramanian

scala> println(name)
subramanian

scala> println("name "+name)
name subramanian

scala> println("Your name is $name" )
Your name is $name

scala> println("Your name is ${name}" )
Your name is ${name}

scala> name = "Ram"
            ^
       error: reassignment to val

scala> var age =18
var age: Int = 18

scala> println(age)
18

scala> age=100
// mutated age

scala> age=80
// mutated age

scala> println(age)
80

scala>
.............................................................................................

Scala tools:

1.scala compiler
 scalac 
2.scala runtime
  scala 

Scala scripting.

FileName.scala

Editors: 
 any text editor
 Ecplise
 Intellij idea.

Build tool for scala

sbt-Simple Build Tool
............................................................................................

How to create scala projects?

you can use sbt in commandline.

 sbt


you can use intellij idea

Code style: normal

HelloWorld.scala

object HelloWorld {
  //main method
  def main(args: Array[String]): Unit = {
    println("Hello")
  }
}

Code Style : dsl style
@main def hello: Unit = 
  println("Hello world!")
  println(msg)

def msg = "I was compiled by Scala 3. :)"
..............................................................................................
					Scala - Language Fundamentals
.............................................................................................

Variables
Types
Literals


Variables in Scala;

variables are declared in two styles

val -  immutable - constants, variables cant be reinitalized
 
var -  mutable  -  variables can reinitalized

package com.mycom

object VariablesDeclaration {
  def main(args: Array[String]): Unit = {
    val a = 10;
    println("A is " + a)
    //a = 100;
    var b = 100
    println("B is " + b)
    b = 900;
    println("B is " + b)

  }
}
..............................................................................................

Type System: Since scala is strongly typed , type of variable should be given.


int a =10; static typed syntax : java

Explicit type declaration
var a:Int  =10;

Type inference: Type of variable is fixed based on values
var a =100;

Types are objects in scala(Wrapper objects)

package com.mycom

object VariablesDeclaration {
  def main(args: Array[String]): Unit = {
    val a = 10;
    println("A is " + a)
    //a = 100;
    var b = 100
    println("B is " + b)
    b = 900;
    println("B is " + b)

    //Explicit type
    var c: Int = 90;
    println("C " + c);

  }
}

Built in data types:

Byte,Int,Long,Short,Double,Float,String

var i =10; ==> default is Int.

var j=10.4 ===>default is double

//java like suffix

var x=10L  => long

var y=10.5F => float

Large Numbers

var a = BigInt(222223232323)

var str="Hello" =>String
var c='c' =>Char

.............................................................................................

String has some special feature:

1.Interpolation : for string concatation 

package com.mycom

object StringsInScala {
  def main(args: Array[String]): Unit = {
    //strings:
    var firstName = "Subramanian";
    var lastName = "Murugan";
    println(s"Name : $firstName $lastName")
  }
}

here s is function for interpolating


2.Multi Line Strings

  //multi line strings
    var htmlDoc =
      """
        |<html>
        |<body>
        |<h1>Hello</h1>
        |</body>
        |</html>
        |""".stripMargin
    println (htmlDoc)
...........................................................................................
Control Structures:
..................

if..else
for loop and expressions
match expression - switch...case
while loop
try...catch

     var a =100;
     if a <0 then
      println("negative")
    else if a==0 then
       println ("zero")
     else
        println ("postive")


Scala code is full of expressions nor statement.

Expressions will give/return some value 
Statement will not return value.

expression

var res = 10 + 10(expression)

var res  = someFunc();

var res = new SomeClass();


package com.mycom

object ControlStructures {
  def main(args: Array[String]): Unit = {
    //control structure // Statement driven
    var a = 100;
    var b = 300;
    if (a < b) {
      println("good value")
    } else {
      println("bad value")
    }
    //control structure // expression driven
    val res = if (a > b) "A is greater" else "B is greater";
    println(res);

  }
}
..............................................................................................
Loops,switch..case
..................

For loops
 traditional for loop
 foreach method
 for expressions -based on eop 

package com.mycom

object Loops {
  def main(args: Array[String]): Unit = {
    //Collection
    //Seq
    val nums = Seq(1, 2, 3)
    for (n <- nums) println(n)
    //List
    val skills = List("Scala", "Java", "Microservices");
    //for loop
    for (skill <- skills) println(skill)
    //for each method
    skills.foreach(skill => println(skill))
    skills.foreach(println)
    //Maps
    val reviews = Map(
      "The Spider Man : No way Home" -> 4,
      "The Matrix Final Chapter " -> 3.5
    )
    for ((movie, rating) <- reviews) println(s"Movie => $movie Rating=> $rating")

  }
}
...........................................................................................
				Switch...case -Java , Match Expressions-Scala
..........................................................................................

Simple Match:

Statement based match

 val month = 3;
    //match expression
    month match {
      case 1 => println("Jan")
      case 2 => println("Feb")
      case 3 => println("Mar")
      case 4 => println("Apr")
      case _ => println("Invalid Month")
    }

Expression based match
 val monthName = month match {
      case 1 => "Jan"
      case 2 => "Feb"
      case 3 => "Mar"
      case 4 => "Apr"
      case _ => "Invalid Month"
    }
    println(monthName)
.........................................................................................

Range matching /List of values Matching

   val num = 6
    val evenOrOdd = num match {
      case 1 | 3 | 5 | 7 | 9 => "odd"
      case 2 | 4 | 6 | 8 | 10 => "even"
      case _ => "No match Found"
    }
    println(evenOrOdd)

    println(evenOrOdd)
    //Range Operator : DSL Code
    num match {
      case a if 0 to 9 contains(a) => println("0 to 9=>" + a)
    }

Advanced match expression to be discussed later.
.............................................................................................
				Object oriented Programming
............................................................................................

if you want to create object, we need class.

class types
1.normal class -  we can create instances
2.object class - SingleTon, which is holding static methods

package com.mycom.oop

class Greeting {
  //instance variables
  var name = "Subramanian";
  var message = "Hello";
}

This is normal class
package com.mycom.oop

/**
 * public class GreetingMain {
 * public static void main(String args[]){
 *
 * }
 * }
 * GreetingMain.main()
 */
//Single ton means , can have static methods , in scala there is no static keyword
object GreetingMain {
  def main(args: Array[String]): Unit = {
    var greeting = new Greeting();
    println(s"${greeting.name} ${greeting.message}")
    greeting = new Greeting(); //constructor call
    greeting.message = "Hai";
    greeting.name = "Ram";
    println(s"${greeting.name} ${greeting.message}")
    //No need of() incase of default constructors
    greeting = new Greeting //constructor call
    println(s"${greeting.name} ${greeting.message}")
  }
}
.............................................................................................

Methods:
 methods are part of classes(instance)

package com.mycom.oop

class Calculator {
  //add methods
  def addV1(): Int = {
    println("Add method")
    return 10 + 10;
  }

  //methods with args
  def addV2(a: Int, b: Int): Int = {
    return a + b;
  }

  //default args
  def addV3(a: Int = 0, b: Int = 0): Int = {
    return a + b;
  }

  //if method having single ling of body ; we can remove {} and return statement
  def addV4(a: Int = 2333, b: Int = 99999): Int = a + b

  //multi line body without return statement
  def addV5(a: Int = 2333, b: Int = 99999): Int = {
    println("addV5")
    println("This is nice syntax")
    a + b // last line of code is implied as return value
  }


}

package com.mycom.oop

object ObjectMethods {
  def main(args: Array[String]): Unit = {
    val calculator = new Calculator;
    println(calculator.addV1())
    println(calculator.addV2(12,30))
    println(calculator.addV3())
    println(calculator.addV3(2,90))
    println(calculator.addV3(12))
    println(calculator.addV4())
    println(calculator.addV5())

  }
}
........
File names and class Names:

in Scala, you can name
.scala files anything you want, no matter what Scala classes or code you
put in them. In general in the case of non-scripts, however, it is recommended
style to name files after the classes they contain as is done in Java.

foo.scala

class Bar {} //valid

but recommended

Bar.scala
class Bar {}

..........................................................................................
constructors:
.............
Types of constructors
1.primary constructors
2.axilary constructors


1.primary constructors.

1.Constructor parameters are declared as part of class Declaration

  class Employee(var id:Int,var name:String) {



  }
2.class body becomes constructors body , so you can call methods directly.

  class Employee(var id:Int,var name:String) {
     println("you can call")
     doStuff()
  }
..........................................

package com.mycom.oop

class Employee(var id: Int = 0, var firstName: String = "", var lastName: String = "") {
  override def toString: String = s"${id} $firstName $lastName"
}

//if class has no methods only data : data class //no necessary of {}
class Stock(var symbol: String = "google", var price: BigDecimal = 100)

//if class has a  releation ship
class Address(
               var street: String = "street",
               var city: String = "city",
               var state: String = "state"
             )

class Customer(var id: Int = 0, var name: String = "name", var address: Address = new Address)

//class constructors are used to have expression

class Guest(var firstName: String = "firstName") {
  //body of the constructor
  println("Guest is being initialized")
  //variables
  var from: String = "From city"

  //methods
  def printCity(): Unit = println(this.firstName, this.from)

  printCity()
}

///Auxiliary class constructors

/**
 * 1.it is special method started with this keyword
 * 2.those constructors must be called by other constructors
 */
class Building(var totalSize: Int = 0, var buildingType: String = "") {
  //one arg aux constructor
  def this(totalSize: Int) = {
    this(totalSize, "Home")
    println("Single Arg constructor is called")
  }

}

package com.mycom.oop

object ConstructorsMain {
  def main(args: Array[String]): Unit = {
    var employee = new Employee; //default constructor
    println(employee.toString)
    employee = new Employee(1, "subramanian", "Murugan"); //default constructor
    println(employee.toString)

    employee = new Employee(3); //default constructor
    println(employee.toString)
    //named parameters : help to pass values in any order
    employee = new Employee(lastName = "Murugan")
    println(employee.toString)

    //instance of Stock
    val stock = new Stock()
    println(stock.price, stock.symbol)

    var customer = new Customer;
    println(customer.id, customer.name, customer.address.city)
    customer = new Customer(id = 1, name = "Subramanian", address = new Address(city = "Coimbatore"))
    println(customer.id, customer.name, customer.address.city)

    //constructor blocks
    var guest = new Guest
    var building = new Building
    building = new Building(1800)
  }
}
.............................................................................................
				  Traits  - Like interfaces in Java
..............................................................................................

Traits:

Traits are a fundamental unit of code reuse in Scala. A trait encapsulates
method and field definitions, which can then be reused by mixing them into
classes. Unlike class inheritance, in which each class must inherit from just
one superclass, a class can mix in any number of traits.

A trait definition looks just like a class definition except that it uses the keyword
trait.

Types:
1.class
2.Interface - traits = abstract classes  + interfaces
3.Enum
4.abstract class

Hierchary: 
 Has-a -Compostion.
 IS-A - inheritance

Inheritance:
=>Code Reuse
=>To avoid code duplication.

Across the application or Across the hierachy.


package com.mycom.oo.traits

//trait
trait Flyable {
  //abstract methods and non abstract methods
  def fly(): String;
}

class AirPlane extends Flyable {
  override def fly(): String = "Airplan is flying"
}

object TraitsDemo {
  def main(args: Array[String]): Unit = {
    // var airPlane:Flyable = new AirPlane;
    var airPlane = new AirPlane;
    println(airPlane.fly);
  }
}
...............................
Mutliple Traits:
package com.mycom.oo.traits

//trait
trait Flyable {
  //abstract methods and non abstract methods
  def fly(): String;
}

trait Landable {
  def land(): String;
}

trait TakeOff {
  def takeOff(): String;
}

class AirPlane extends Flyable with Landable with TakeOff {
  override def fly(): String = "Airplan is flying"

  override def land(): String = "Landing Process begins";

  override def takeOff(): String = "Take Off Process begins"
}

object TraitsDemo {
  def main(args: Array[String]): Unit = {
    // var airPlane:Flyable = new AirPlane;
    var airPlane = new AirPlane;
    println(airPlane.fly, airPlane.land, airPlane.takeOff);
  }
}
............................................................................................

Trait and concrete Methods:
trait Pet {
  def speak = println("wo wo wo") // concrete implementation of a speak method

  def eat(): String // abstract
}

class Dog extends Pet {
  override def eat(): String = "Dog eats meat and bones"
}

def main(args: Array[String]): Unit = {
    // var airPlane:Flyable = new AirPlane;
    var airPlane = new AirPlane;
    println(airPlane.fly, airPlane.land, airPlane.takeOff);
    ///
    var pet = new Dog;
    pet.speak
    println(pet.eat)

}
............................................................................................
	   Anonomous Classes: without Implementation class we can write logic
		Runtime Inheritance: BindingMixing traits in on the fly

Use case 1:without any class


    var myCat = new Pet {
      override def eat(): String = "Cat is drinking Milk"
    }
    myCat.speak
    println(myCat.eat)

Use case 2: with class but binding happens dynamically.


trait Pet {
  def speak = println("wo wo wo") // concrete implementation of a speak method

  def eat(): String // abstract
}

def cat = new Cat("puppy") with Pet {
      override def eat(): String = "Cat Drinks milk"
    }
    cat.speak
    println(cat.eat)

......
// this won’t compile
trait Animal(name: String)


Abstract classes:
 Like java classes.

Therefore, you need to use an abstract class whenever a base behavior must have constructor parameters:

abstract class Pet(name: String) {
  def speak: Unit = println(s"My name is $name")
  //non abstracts
  def takeCare(): Unit = {
    println("Take Care Pets")
  }
}

class Dog(name: String) extends Pet(name)

object AbstractClassesDemo {
  def main(args: Array[String]): Unit = {
    var dog = new Dog("Fido")
    dog.speak
    dog.takeCare
  }
}

}
..........................................................................................

package com.mycom.oop.advancedmatch

trait Person {
  def name: String
}

case class Student(name: String, year: Int) extends Person

case class Teacher(name: String, specialty: String) extends Person

class CasePrinter {
  def getPrintableString(p: Person): String = p match {
    case Student(name, year) =>
      s"$name is a student in Year $year."
    case Teacher(name, whatTheyTeach) =>
      s"$name teaches $whatTheyTeach."
  }
}

object AdvancedMatchClass {
  def main(args: Array[String]): Unit = {
    val casePrinter = new CasePrinter
    println(casePrinter.getPrintableString(new Student("Ram", 3)))
    println(casePrinter.getPrintableString(new Teacher("Subramanian", "Scala")))

  }
}
package com.mycom.oop.advancedmatch

trait Person {
  def name: String
}

case class Student(name: String, year: Int) extends Person

case class Teacher(name: String, specialty: String) extends Person

class CasePrinter {
  def getPrintableString(p: Person): String = p match {
    case Student(name, year) =>
      s"$name is a student in Year $year."
    case Teacher(name, whatTheyTeach) =>
      s"$name teaches $whatTheyTeach."
  }
}

//case class Methods
case class IPLTeam(name: String, lastWorldSeriesWin: Int)

object AdvancedMatchClass {
  def main(args: Array[String]): Unit = {
    val casePrinter = new CasePrinter
    println(casePrinter.getPrintableString(new Student("Ram", 3)))
    println(casePrinter.getPrintableString(new Teacher("Subramanian", "Scala")))

    val cubs1908 = IPLTeam("CSK", 2021)
    println(cubs1908.name, cubs1908.lastWorldSeriesWin)

    val cubs2016 = cubs1908.copy(lastWorldSeriesWin = 2017)
    
    println(cubs2016.name, cubs2016.lastWorldSeriesWin)

  }
}
..............................................................................................

Built in Usefull Traits:

Null, null, Nil, Nothing, None, and Unit in Scala
....................................................

Null– Its a Trait.
null– Its an instance of Null- Similar to Java null.

Nil– Represents an emptry List of anything of zero length. Its not that it refers to nothing but it refers to List which has no contents.

Nothing is a Trait. Its a subtype of everything. But not superclass of anything. There are no instances of Nothing.

None– Used to represent a sensible return value. Just to avoid null pointer exception. Option has exactly 2 subclasses- Some and None. None signifies no result from the method.

Unit– Type of method that doesn’t return a value of anys sort.
...............................................................................................				Functional Programming
..............................................................................................
				










































































































   

   

 